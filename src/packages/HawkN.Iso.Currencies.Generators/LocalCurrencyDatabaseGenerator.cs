using System.Reflection;
using System.Text;
using HawkN.Iso.Currencies.Generators.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
namespace HawkN.Iso.Currencies.Generators;

[Generator]
public class LocalCurrencyDatabaseGenerator : BaseIncrementalGenerator
{
    protected override string HintName => "LocalCurrencyDatabase.g.cs";
    private const string StubSource = """
                                      // <auto-generated>
                                      //     This file was generated by HawkN.Iso.Currencies.Generators source generator.
                                      //     Do not modify this file manually.
                                      // </auto-generated>
                                      #nullable enable
                                      using System.Collections.Generic;
                                      using System.Collections.Immutable;
                                      using HawkN.Iso.Currencies.Models;
                                      namespace HawkN.Iso.Currencies
                                      {
                                          /// <summary> Currency information for codes ISO4217 </summary>
                                          internal static class LocalCurrencyDatabase
                                          {
                                              /// <summary> Actual currency information for codes ISO4217 </summary>
                                              public static readonly ImmutableArray<Models.Currency> ActualCurrencies = ImmutableArray.Create(
                                                new Models.Currency[]{});
                                          }
                                      }
                                      """;

    public override void Initialize(IncrementalGeneratorInitializationContext context)
    {
        ErrorFactory.Clear();
        var jsonProvider = context.CompilationProvider.Select(ReadDataResource);
        context.RegisterSourceOutput(jsonProvider, (spc, tuple) => GenerateSourceOutput(tuple, spc));
    }

    static (string, string, string, string) ReadDataResource(Compilation compilation, CancellationToken ct)
    {
        try
        {
            return LoadResources(Assembly.GetExecutingAssembly());
        }
        catch (InvalidOperationException ex)
        {
            var errorMsg = $"{Constants.ErrorMark}:{ex.Message}";
            return (errorMsg, errorMsg, errorMsg, errorMsg);
        }
    }

    private void GenerateSourceOutput((string originalXml, string translationsXml, string replacementJson, string currencyCodesCsv) tuple,
        SourceProductionContext spc)
    {
        try
        {
            if (HasResourceErrors(tuple, out var errorMessages))
            {
                foreach (var msg in errorMessages)
                    ReportResourceError(msg);

                AddStubIfErrors(spc, HintName, StubSource, GeneratorType.Database);
                return;
            }

            var loader = new CurrencyDataLoader(tuple.originalXml, tuple.translationsXml, tuple.replacementJson, tuple.currencyCodesCsv);
            var sb = CreateSourceBuilder(
                Constants.GeneratorName,
                Constants.DefaultNamespace,
                Constants.ExtendedSourceData,
                [
                    "System.Collections.Generic",
                    "System.Collections.Immutable",
                    "HawkN.Iso.Currencies.Models"
                ]);

            sb.AppendLine("    /// <summary> Currency information for codes ISO4217 </summary>")
                .AppendLine("    internal static class LocalCurrencyDatabase")
                .AppendLine("    {");

            GenerateCurrencySection(sb, "ActualCurrencies", loader.ActualCurrencyData);

            sb.AppendLine("    }").AppendLine("}");

            var count = 2;
            foreach (var currency in loader.ActualCurrencyData.Currencies.Where(currency => currency.NumericCode.Length < 3))
            {
                count++;
                ErrorFactory.Create(new ErrorDescription
                {
                    DiagnosticDescriptor = new DiagnosticDescriptor(
                        CreateDescriptorId(count.ToString()),
                        string.Empty,
                        $"Empty or invalid numeric code for the currency: `{currency.Code}`",
                        string.Empty,
                        DiagnosticSeverity.Error,
                        true),
                    GeneratorType = GeneratorType.Database
                });
            }
            if (ErrorFactory.IsExists())
            {
                AddStubIfErrors(spc, HintName, StubSource, GeneratorType.Database);
                return;
            }
            spc.AddSource(HintName, SourceText.From(sb.ToString(), Encoding.UTF8));
        }
        catch (Exception ex)
        {
            ErrorFactory.Create(new ErrorDescription
            {
                DiagnosticDescriptor = new DiagnosticDescriptor(
                    CreateDescriptorId("0"),
                    Constants.DiagnosticsTitle,
                    $"Unexpected exception: {ex.Message}. Stacktrace: {ex.StackTrace}",
                    string.Empty,
                    DiagnosticSeverity.Error,
                    true),
                GeneratorType = GeneratorType.Database
            });
            AddStubIfErrors(spc, HintName, StubSource, GeneratorType.Database);
        }
    }

    private static bool HasResourceErrors((string originalXml, string translationsXml, string replacementJson, string currencyCodesCsv) tuple,
        out List<string> messages)
    {
        messages = [];
        if (tuple.originalXml.StartsWith(Constants.ErrorMark)) messages.Add("original:" + tuple.originalXml);
        if (tuple.replacementJson.StartsWith(Constants.ErrorMark)) messages.Add("replacement:" + tuple.replacementJson);
        if (tuple.translationsXml.StartsWith(Constants.ErrorMark)) messages.Add("translations:" + tuple.translationsXml);
        if (tuple.currencyCodesCsv.StartsWith(Constants.ErrorMark)) messages.Add("codes:" + tuple.currencyCodesCsv);
        return messages.Count > 0;
    }

    private static void GenerateCurrencySection(StringBuilder sb, string propertyName, CurrencyData data,
        bool isHistorical = false)
    {
        sb.AppendLine("        /// <summary>")
            .AppendLine(
                $"        /// {(isHistorical ? "Currency historical" : "Actual currency")} information for codes ISO4217");
        if (!string.IsNullOrEmpty(data.PublishedDate))
            sb.AppendLine($"        /// Last published at {data.PublishedDate}.");
        sb.AppendLine("        /// </summary>");

        sb.AppendLine(
                $"        public static readonly ImmutableArray<Models.Currency> {propertyName} = ImmutableArray.Create(new Models.Currency[]")
            .AppendLine("        {");
        foreach (var c in data.Currencies)
        {
            var currencyType = c.CurrencyType != null
                ? $"CurrencyType.{c.CurrencyType}"
                : "null";
            int.TryParse(c.NumericCode, out var numericCode);
            sb.AppendLine(
                $"            new(\"{c.Code}\", \"{c.Name}\", {numericCode}, {currencyType}),");
        }

        sb.AppendLine("        });");
    }

    private void ReportResourceError(string msg)
    {
        var parts = msg.Split([':'], 2);
        var name = parts[0];
        var text = parts.Length > 1 ? parts[1] : "Unknown error";

        ErrorFactory.Create(new ErrorDescription
        {
            DiagnosticDescriptor = new DiagnosticDescriptor(
                CreateDescriptorId("1"),
                Constants.DiagnosticsTitle,
                $"Failed to load {name} resource: {text}",
                string.Empty,
                DiagnosticSeverity.Error,
                true),
            GeneratorType = GeneratorType.Database
        });
    }
}